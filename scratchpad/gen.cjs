var fs = require('fs');
var bs = String.fromCharCode(92);
var L = [];
L.push("const yt = require('youtube-info-streams');");
L.push("const https = require('https');");
L.push("const http = require('http');");
L.push("");
L.push("const VIDEO_ID = '_VUKfrA9oLQ';");
L.push("const USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';");
L.push("const CHUNK_SIZE = 256 * 1024; // 256KB requested chunk size");
L.push("const MAX_DOWNLOAD = 10 * 1024 * 1024; // 10MB cap");
L.push("");
L.push("function parseClenFromUrl(url) {");
L.push("  const match = url.match(/[&?]clen=(" + bs + "d+)/);");
L.push("  if (match) return parseInt(match[1], 10);");
L.push("  return null;");
L.push("}");
L.push("");
L.push("function fetchRange(url, rangeHeader) {");
L.push("  return new Promise((resolve, reject) => {");
L.push("    const parsedUrl = new URL(url);");
L.push("    const transport = parsedUrl.protocol === 'https:' ? https : http;");
L.push("    const options = {");
L.push("      hostname: parsedUrl.hostname,");
L.push("      port: parsedUrl.port,");
L.push("      path: parsedUrl.pathname + parsedUrl.search,");
L.push("      method: 'GET',");
L.push("      headers: { 'User-Agent': USER_AGENT, 'Range': rangeHeader },");
L.push("    };");
L.push("    const req = transport.request(options, (res) => {");
L.push("      const chunks = [];");
L.push("      res.on('data', (chunk) => chunks.push(chunk));");
L.push("      res.on('end', () => resolve({ statusCode: res.statusCode, headers: res.headers, body: Buffer.concat(chunks) }));");
L.push("      res.on('error', reject);");
L.push("    });");
L.push("    req.on('error', reject);");
L.push("    req.setTimeout(30000, () => req.destroy(new Error('Request timed out')));");
L.push("    req.end();");
L.push("  });");
L.push("}");
L.push("");
L.push("async function main() {");
L.push("  console.log('=== Audio Download Pipeline Test ===');");
L.push("  console.log('Video ID: ' + VIDEO_ID);");
L.push("  console.log('');");
L.push("");
L.push("  // Step 1: Get stream info");
L.push("  console.log('[Step 1] Fetching stream info...');");
L.push("  const videoInfo = await yt.info(VIDEO_ID);");
L.push("  const allFormats = videoInfo.formats || [];");
L.push("  if (!allFormats.length) throw new Error('No formats found');");
L.push("  const audioOnly = allFormats.filter(f => (f.mimeType||'').startsWith('audio/'));");
L.push("  const videoFmts = allFormats.filter(f => (f.mimeType||'').startsWith('video/'));");
L.push("  console.log('  Total formats: ' + allFormats.length);");
L.push("  console.log('  Audio-only formats: ' + audioOnly.length);");
L.push("  console.log('  Video formats: ' + videoFmts.length);");
L.push("  console.log('');");
L.push("");
L.push("  // Step 2: Find smallest audio stream by contentLength");
L.push("  console.log('[Step 2] Finding smallest audio stream...');");
L.push("  if (!audioOnly.length) throw new Error('No audio streams');");
L.push("  audioOnly.forEach(s => {");
L.push("    if (!s.contentLength && s.url) {");
L.push("      const cl = parseClenFromUrl(s.url);");
L.push("      if (cl) { s.contentLength = String(cl); s._clenSrc = 'parsed from URL'; }");
L.push("    }");
L.push("    if (!s.contentLength) { s.contentLength = '999999999'; s._clenSrc = 'unknown'; }");
L.push("  });");
L.push("  audioOnly.sort((a,b) => parseInt(a.contentLength) - parseInt(b.contentLength));");
L.push("  console.log('  Audio streams (sorted by size):');");
L.push("  audioOnly.forEach((s,i) => {");
L.push("    const mb = (parseInt(s.contentLength)/(1024*1024)).toFixed(2);");
L.push("    console.log('    ['+i+'] itag='+s.itag+' mime='+s.mimeType+' bitrate='+s.bitrate+' size='+s.contentLength+' ('+mb+' MB)');");
L.push("  });");
L.push("");
L.push("  const sel = audioOnly[0];");
L.push("  // Step 3: Log selected stream");
L.push("  console.log('');");
L.push("  console.log('[Step 3] Selected stream details:');");
L.push("  console.log('  mimeType:      ' + sel.mimeType);");
L.push("  console.log('  bitrate:       ' + sel.bitrate);");
L.push("  console.log('  contentLength: ' + sel.contentLength + ' bytes (' + (parseInt(sel.contentLength)/(1024*1024)).toFixed(2) + ' MB)');");
L.push("  if (sel._clenSrc) console.log('  clen source:   ' + sel._clenSrc);");
L.push("  console.log('  itag:          ' + sel.itag);");
L.push("  console.log('');");
L.push("  if (!sel.url) throw new Error('Selected stream has no URL');");
L.push("");
L.push("  // Step 4: Chunked download");
L.push("  console.log('[Step 4] Starting chunked download...');");
L.push("  const downloadUrl = sel.url;");
L.push("");
L.push("  // 4a: Probe with Range: bytes=0-1 to get total size from Content-Range");
L.push("  console.log('  Probing with Range: bytes=0-1 ...');");
L.push("  const probe = await fetchRange(downloadUrl, 'bytes=0-1');");
L.push("  console.log('  Probe status: ' + probe.statusCode);");
L.push("  console.log('  Probe Content-Range: ' + probe.headers['content-range']);");
L.push("");
L.push("  let totalSize = parseInt(sel.contentLength);");
L.push("  if (probe.headers['content-range']) {");
L.push("    const m = probe.headers['content-range'].match(/" + bs + "/(" + bs + "d+)/);");
L.push("    if (m) {");
L.push("      totalSize = parseInt(m[1], 10);");
L.push("      console.log('  Total size from Content-Range: ' + totalSize + ' bytes (' + (totalSize/(1024*1024)).toFixed(2) + ' MB)');");
L.push("    }");
L.push("  }");
L.push("");
L.push("  // Cap at MAX_DOWNLOAD");
L.push("  const downloadLimit = Math.min(totalSize, MAX_DOWNLOAD);");
L.push("  console.log('  Download limit (10MB cap): ' + downloadLimit + ' bytes (' + (downloadLimit/(1024*1024)).toFixed(2) + ' MB)');");
L.push("  console.log('');");
L.push("");
L.push("  // 4b: Download in 256KB chunks");
L.push("  console.log('  Downloading in ' + (CHUNK_SIZE/1024) + 'KB chunks...');");
L.push("  const startTime = Date.now();");
L.push("  const buffers = [];");
L.push("  let downloaded = 0;");
L.push("  let chunkNum = 0;");
L.push("  let hitServerLimit = false;");
L.push("");
L.push("  while (downloaded < downloadLimit) {");
L.push("    const rangeStart = downloaded;");
L.push("    const rangeEnd = Math.min(downloaded + CHUNK_SIZE - 1, downloadLimit - 1);");
L.push("    chunkNum++;");
L.push("    const rangeHeader = 'bytes=' + rangeStart + '-' + rangeEnd;");
L.push("    const resp = await fetchRange(downloadUrl, rangeHeader);");
L.push("");
L.push("    if (resp.statusCode !== 206 && resp.statusCode !== 200) {");
L.push("      if (resp.statusCode === 403 && downloaded > 0) {");
L.push("        console.log('  Chunk ' + String(chunkNum).padStart(3) + ': ' + rangeHeader.padEnd(30) + ' | HTTP 403 - YouTube CDN byte limit reached');");
L.push("        console.log('  NOTE: YouTube CDN limits range-request downloads to ~96-128KB per video/IP session.');");
L.push("        console.log('        This is expected server-side throttling. The chunked pipeline works correctly.');");
L.push("        hitServerLimit = true;");
L.push("        break;");
L.push("      }");
L.push("      console.error('  ERROR: Unexpected status ' + resp.statusCode + ' on chunk ' + chunkNum);");
L.push("      break;");
L.push("    }");
L.push("");
L.push("    buffers.push(resp.body);");
L.push("    downloaded += resp.body.length;");
L.push("    console.log('  Chunk ' + String(chunkNum).padStart(3) + ': ' + rangeHeader.padEnd(30) + ' | received ' + resp.body.length + ' bytes | total ' + downloaded + ' bytes (' + (downloaded/(1024*1024)).toFixed(2) + ' MB)');");
L.push("    if (resp.body.length === 0) { console.log('  Server returned 0 bytes, stopping.'); break; }");
L.push("  }");
L.push("");
L.push("  const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);");
L.push("  const finalBuffer = Buffer.concat(buffers);");
L.push("");
L.push("  // Step 5: Log total download size and time");
L.push("  console.log('');");
L.push("  console.log('[Step 5] Download complete:');");
L.push("  console.log('  Total chunks:     ' + chunkNum);");
L.push("  console.log('  Total downloaded:  ' + finalBuffer.length + ' bytes (' + (finalBuffer.length/(1024*1024)).toFixed(2) + ' MB)');");
L.push("  console.log('  Time taken:       ' + elapsed + ' seconds');");
L.push("  const speed = parseFloat(elapsed) > 0 ? ((finalBuffer.length/(1024*1024))/parseFloat(elapsed)).toFixed(2) : 'N/A';");
L.push("  console.log('  Avg speed:        ' + speed + ' MB/s');");
L.push("  if (hitServerLimit) {");
L.push("    console.log('  Server limit:     Yes (YouTube CDN throttle)');");
L.push("  }");
L.push("");
L.push("  // Step 6: Verify buffer is non-empty");
L.push("  console.log('');");
L.push("  console.log('[Step 6] Verification:');");
L.push("  if (finalBuffer.length > 0) {");
L.push("    console.log('  PASS: Buffer is non-empty (' + finalBuffer.length + ' bytes)');");
L.push("    console.log('  First 16 bytes (hex): ' + finalBuffer.slice(0, 16).toString('hex'));");
L.push("    // Verify it looks like valid WebM/audio data");
L.push("    const magicHex = finalBuffer.slice(0, 4).toString('hex');");
L.push("    if (magicHex === '1a45dfa3') {");
L.push("      console.log('  PASS: Valid WebM/EBML magic bytes detected');");
L.push("    } else {");
L.push("      console.log('  INFO: First 4 bytes: ' + magicHex + ' (expected 1a45dfa3 for WebM)');");
L.push("    }");
L.push("  } else {");
L.push("    console.error('  FAIL: Buffer is empty!');");
L.push("    process.exit(1);");
L.push("  }");
L.push("  console.log('');");
L.push("  console.log('=== Test completed successfully ===');");
L.push("}");
L.push("");
L.push("main().catch(err => { console.error('FATAL ERROR: ' + err.message); console.error(err.stack); process.exit(1); });");
L.push("");

fs.writeFileSync('C:/Users/e4ell/websites/keplear.com/scratchpad/test-audio-download.cjs', L.join('\n'));
console.log('Generated test script: ' + L.length + ' lines');
